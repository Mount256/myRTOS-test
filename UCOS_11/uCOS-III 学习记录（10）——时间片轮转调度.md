参考内容：《[野火]uCOS-III内核实现与应用开发实战指南——基于STM32》第 14 章。

[toc]

## 0 时间片轮转的意义

我们现在实现的 uCOS 内核，包含了就绪列表和时基列表。就绪列表的插入规则与优先级有关，而时基列表的插入规则与时基计数器和延时时间有关。上一篇文章中，已经实现了时基列表的任务调度。但是我们写的内核还有一些缺陷，当不进行任务调度时（**注意：任务调度的实质是切换到高优先级的任务去执行**），系统只能执行就绪列表下的双向链表头指针对应的任务，那么相同优先级的其他任务就执行不到了。因此，我们希望相同优先级的多个任务都可以执行到，其中一个办法就是每隔一段时间就切换到相同优先级上的任务，这样这些任务都有机会被运行到。

**时间片轮转调度用于解决相同优先级下多个任务的运行问题**。现在假设 A 优先级下有任务 1、任务 2、任务 3，B 优先级有任务 4 且被阻塞 6 个时间片的长度，所以现在要运行 A 优先级下的任务。
- 如果不实现时间片轮转，那么 A 优先级排在最前面的任务 1 将运行 6 个时间片，即独占了这 6 个时间片。
- 如果实现时间片轮转，那么 A 优先级下的任务可以商量好，大家这样来：任务 1 先运行 2 个时间片，任务 2 再运行 2 个时间片，最后任务 3 也运行 2 个时间片，很公平，大家都被运行了。当然，也不一定平均分配，比如任务 1 先运行 1 个时间片，任务 2 再运行 2 个时间片，最后任务 3 运行 3 个时间片，这样也可以。

相同优先级的任务，谁都可以被运行，这就是时间片轮转调度带来的好处了。现在，我们就来实现这个机制。

## 1 修改任务控制块 TCB（os.h）

在实现轮转调度之前，先添加 TCB 的成员，有两个：
- TimeQuanta：用于记录该任务需要多少个时间片，这个值设置好后一般是不动的。
- TimeQuantaCtr：用于时间片计数，表示任务剩余的时间片个数。一旦数到了零，说明该任务已经用完了时间片，需要切换其他任务了。

```c
struct os_tcb{
	CPU_STK			*StkPtr;
	CPU_STK_SIZE	StkSize;
	
	OS_PRIO			Prio;				/* 任务优先级 */
	
	OS_TCB			*NextPtr;			/* 就绪列表双向链表的下一个指针 */
	OS_TCB			*PrevPtr;			/* 就绪列表双向链表的前一个指针 */
	
	OS_TCB			*TickNextPtr;		/* 指向链表的下一个 TCB 节点 */
	OS_TCB			*TickPrevPtr;		/* 指向链表的上一个 TCB 节点 */
	OS_TICK_SPOKE	*TickSpokePtr;		/* 用于回指到链表根部 */
	OS_TICK			TickCtrMatch;		/* 该值等于时基计数器 OSTickCtr 的值加上 TickRemain 的值 */
	OS_TICK			TickRemain;			/* 设置任务还需要等待多少个时钟周期 */
	
	OS_TICK			TimeQuanta;			/* 任务需要多少个时间片 */
	OS_TICK			TimeQuantaCtr;		/* 任务剩余的时间片个数 */
};
```

## 2 时间片轮转调度函数

## 3 修改相关代码

## 4 时间片轮调度的应用
